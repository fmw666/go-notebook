{"./":{"url":"./","title":"Introduction","keywords":"","body":"IntroductionIntroduction 仅作为课程笔记使用。 powered by Gitbook最后修改于 2022-10-24 22:59:49 "},"part1/ch1.html":{"url":"part1/ch1.html","title":"核心 Go 技能","keywords":"","body":"核心 Go 技能核心 Go 技能 Go 最关键的几个特性：goroutine、channel、error、context Runtime 中核心类型：chan、slice、map Go toolchain 内存模型 并发语义 网络开发 大规模项目的工程化实践 Kernel 综合知识对工程师代码的反向要求 powered by Gitbook最后修改于 2022-10-24 22:51:16 "},"part2/ch1.html":{"url":"part2/ch1.html","title":"第一个 Go 程序","keywords":"","body":"第一个 Go 程序第一个 Go 程序 程序代码： demo.go package main func main() { println(\"Hello World!\") } 运行命令： > go run demo.go powered by Gitbook最后修改于 2022-10-24 23:08:48 "},"part2/ch2.html":{"url":"part2/ch2.html","title":"string 长度","keywords":"","body":"string 长度string 长度 注意下面代码及其输出： println(len(\"你好\")) // 6 println(utf8.RuneCountInString(\"你好\")) // 2 println(utf8.RuneCountInString(\"你好ab\")) // 4 len(str) 获取字节长度，和编码无关。 RuneCountInString 获取字符数量，和编码有关。 powered by Gitbook最后修改于 2022-10-24 23:19:24 "},"part2/ch3.html":{"url":"part2/ch3.html","title":"goroutine","keywords":"","body":"goroutinegoroutine 用关键字 go 启动： package main import ( \"fmt\" \"time\" ) func main() { GoRoutine() } func GoRoutine() { go func() { time.Sleep(10 * time.Second) }() // 不会等待 10 秒才执行 fmt.Println(\"I am here\") } powered by Gitbook最后修改于 2022-10-25 14:32:20 "},"part2/ch4.html":{"url":"part2/ch4.html","title":"channel","keywords":"","body":"channelchannel 带缓存和不带缓存： package main import ( \"fmt\" \"time\" ) func main() { channelWithoutCache() channelWithCache() } func channelWithoutCache() { ch := make(chan string, 1) go func() { ch select 顺序是不定的： func Select() { ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(time.Second) ch1 powered by Gitbook最后修改于 2022-10-25 16:41:26 "},"part3/ch1.html":{"url":"part3/ch1.html","title":"微服务概览","keywords":"","body":"微服务概览单体架构微服务起源微服务定义微服务的不足基础设施自动化微服务概览 单体架构 尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。应用无法扩展，可靠性很低，最终，敏捷性开发和部署变的无法完成。 我们应对的思路：化繁为简，分而治之 微服务起源 大家经常谈论的是一个叫 SOA (面向服务的架构模式)，它和微服务又是什么关系？你可以把微服务想成是 SOA 的一种实践。 小即是美：小的服务代码少，bug 也少，易测试，易维护，也更容易不断迭代完善的精致进而美妙。 单一职责：一个服务也只需要做好一-件事，专注才能做好。 尽可能早地创建原型：尽可能早的提供服务API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。 可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性者间，首要依然考虑兼容性和移植性。 You should instead think of Microservices as a specific approach for SOA in the same way that XP or Scrum are specific approaches for Agile software development. 微服务定义 围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活: 原子服务 独立进程 隔离部署 去中心化服务治理 缺点： 基础设施的建设、复杂度高 微服务的不足 Fred Brooks在30年前写道，“there are no silver”。但凡事有利就有弊，微服务也不是万能的。 微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用RPC或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。 分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。 测试一个基于微服务架构的应用也是很复杂的任务。 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。 对运维基础设施的挑战比较大。 基础设施自动化 无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为-系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。 CICD：Gitlab + Gitlab Hooks + kubernetes Testing：测试环境、单元测试、API 自动化测试 在线运行时：kubernetes，以及一系列Prometheus、ELK、Conrtol Panle powered by Gitbook最后修改于 2022-10-26 02:23:35 "},"part3/ch2.html":{"url":"part3/ch2.html","title":"微服务设计","keywords":"","body":"微服务设计API Gateway微服务设计 API Gateway 我们进行了 SOA 服务化的架构演进，按照垂直功能进行了拆分，对外暴露了一批微服务，但是因为缺乏统的出口面临了不少困难： 客户端到微服务直接通信，强耦合。 需要多次请求，客户端聚合数据，工作量巨大，延迟高。 协议不利于统一，各个部门间有差异，需要端来兼容。 面向“端”的 API 适配，耦合到了内部服务。 多终端兼容逻辑复杂，每个服务都需要处理。 统一逻辑无法收敛，比如安全认证、限流。 我们新增了一个 app-interface 用于统一的协议出口，在服务内进行大量的 dataset join，按照业务场景来设计粗粒度的 API，给后续服务的演进带来的很多优势： 轻量交互：协议精简、聚合。 差异服务：数据裁剪以及聚合、针对终端定制化 API。 动态升级：原有系统兼容升级，更新服务而非协议。 通效率提升，协作模式演进为移动业务+网关小组。 BFF（Backend for Frontend）可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的 API，方便无线设备接入访问后端服务。 最致命的一个问题是整个 app-interface 属于 single point of failure，严重代码缺陷或者流量洪峰可能引发集群宕机。 跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(路由、认证、限流、安全)，因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 APIGateway 进行了分层处理。 在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF 实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发入员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。 我们业务流量实际为: 移动端-> API Gateway -> BFF -> Mircoservice，在 FE Web 业务中，BFF 可以是 nodejs 来做服务端渲染(SSR, Server-Side Rendering)，注意这里忽略了上游的 CDN、4/7 层 负载均衡（ELD）。 powered by Gitbook最后修改于 2022-10-26 18:52:12 "},"part3/ch3.html":{"url":"part3/ch3.html","title":"gRPC & 服务发现","keywords":"","body":"gRPC & 服务发现gRPCgRPC & 服务发现 gRPC gRPC 是什么可以用官网的一句话来概括： \"A high-performance, open-source universal RPC framework\" 多语言：语言中立，支持多种语言 轻量级、高性能：序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架。 可插拔 IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。 设计理念 移动端：基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。 powered by Gitbook最后修改于 2022-10-27 12:51:38 "},"part4/ch1.html":{"url":"part4/ch1.html","title":"Error vs Exception","keywords":"","body":"Error vs ExceptionErrorError vs Exception Error powered by Gitbook最后修改于 2022-10-27 17:19:47 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"TermAnother termTerm Definition for this term Another term With it's definition, this can contain bold text and all other kinds of inline markup ... powered by Gitbook最后修改于 2022-06-29 22:58:50 "}}