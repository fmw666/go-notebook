{"./":{"url":"./","title":"Introduction","keywords":"","body":"IntroductionIntroduction 仅作为课程笔记使用。 powered by Gitbook最后修改于 2022-10-24 22:59:49 "},"part1/ch1.html":{"url":"part1/ch1.html","title":"核心 Go 技能","keywords":"","body":"核心 Go 技能核心 Go 技能 Go 最关键的几个特性：goroutine、channel、error、context Runtime 中核心类型：chan、slice、map Go toolchain 内存模型 并发语义 网络开发 大规模项目的工程化实践 Kernel 综合知识对工程师代码的反向要求 powered by Gitbook最后修改于 2022-10-24 22:51:16 "},"part2/ch1.html":{"url":"part2/ch1.html","title":"第一个 Go 程序","keywords":"","body":"第一个 Go 程序第一个 Go 程序 程序代码： demo.go package main func main() { println(\"Hello World!\") } 运行命令： > go run demo.go powered by Gitbook最后修改于 2022-10-24 23:08:48 "},"part2/ch2.html":{"url":"part2/ch2.html","title":"string 长度","keywords":"","body":"string 长度string 长度 注意下面代码及其输出： println(len(\"你好\")) // 6 println(utf8.RuneCountInString(\"你好\")) // 2 println(utf8.RuneCountInString(\"你好ab\")) // 4 len(str) 获取字节长度，和编码无关。 RuneCountInString 获取字符数量，和编码有关。 powered by Gitbook最后修改于 2022-10-24 23:19:24 "},"part2/ch3.html":{"url":"part2/ch3.html","title":"goroutine","keywords":"","body":"goroutinegoroutine 用关键字 go 启动： package main import ( \"fmt\" \"time\" ) func main() { GoRoutine() } func GoRoutine() { go func() { time.Sleep(10 * time.Second) }() // 不会等待 10 秒才执行 fmt.Println(\"I am here\") } powered by Gitbook最后修改于 2022-10-25 14:32:20 "},"part2/ch4.html":{"url":"part2/ch4.html","title":"channel","keywords":"","body":"channelchannel 带缓存和不带缓存： package main import ( \"fmt\" \"time\" ) func main() { channelWithoutCache() channelWithCache() } func channelWithoutCache() { ch := make(chan string, 1) go func() { ch select 顺序是不定的： func Select() { ch1 := make(chan string) ch2 := make(chan string) go func() { time.Sleep(time.Second) ch1 powered by Gitbook最后修改于 2022-10-25 16:41:26 "},"part3/ch1.html":{"url":"part3/ch1.html","title":"微服务概览","keywords":"","body":"微服务概览单体架构微服务起源微服务定义微服务的不足基础设施自动化微服务概览 单体架构 尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。应用无法扩展，可靠性很低，最终，敏捷性开发和部署变的无法完成。 我们应对的思路：化繁为简，分而治之 微服务起源 大家经常谈论的是一个叫 SOA (面向服务的架构模式)，它和微服务又是什么关系？你可以把微服务想成是 SOA 的一种实践。 小即是美：小的服务代码少，bug 也少，易测试，易维护，也更容易不断迭代完善的精致进而美妙。 单一职责：一个服务也只需要做好一-件事，专注才能做好。 尽可能早地创建原型：尽可能早的提供服务API，建立服务契约，达成服务间沟通的一致性约定，至于实现和完善可以慢慢再做。 可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性者间，首要依然考虑兼容性和移植性。 You should instead think of Microservices as a specific approach for SOA in the same way that XP or Scrum are specific approaches for Agile software development. 微服务定义 围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活: 原子服务 独立进程 隔离部署 去中心化服务治理 缺点： 基础设施的建设、复杂度高 微服务的不足 Fred Brooks在30年前写道，“there are no silver”。但凡事有利就有弊，微服务也不是万能的。 微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用RPC或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。 分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。 测试一个基于微服务架构的应用也是很复杂的任务。 服务模块间的依赖，应用的升级有可能会波及多个服务模块的修改。 对运维基础设施的挑战比较大。 基础设施自动化 无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为-系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。 CICD：Gitlab + Gitlab Hooks + kubernetes Testing：测试环境、单元测试、API 自动化测试 在线运行时：kubernetes，以及一系列Prometheus、ELK、Conrtol Panle powered by Gitbook最后修改于 2022-10-26 02:23:35 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"TermAnother termTerm Definition for this term Another term With it's definition, this can contain bold text and all other kinds of inline markup ... powered by Gitbook最后修改于 2022-06-29 22:58:50 "}}